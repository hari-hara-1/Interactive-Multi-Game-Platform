<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reversi React</title>
    <link rel="stylesheet" href="style.css">
    
    <!-- React, ReactDOM, and Babel from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        const BOARD_SIZE = 8;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        const DIRECTIONS = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        function App() {
            const [board, setBoard] = useState([]);
            const [currentPlayer, setCurrentPlayer] = useState(BLACK);
            const [gameStatus, setGameStatus] = useState({ 
                isOver: false, 
                message: '', 
                blackScore: 2, 
                whiteScore: 2 
            });
            const [validMoves, setValidMoves] = useState([]);

            // Initialize Game
            const initGame = useCallback(() => {
                const newBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
                const mid = BOARD_SIZE / 2;
                newBoard[mid-1][mid-1] = WHITE;
                newBoard[mid-1][mid] = BLACK;
                newBoard[mid][mid-1] = BLACK;
                newBoard[mid][mid] = WHITE;

                setBoard(newBoard);
                setCurrentPlayer(BLACK);
                setGameStatus({
                    isOver: false,
                    message: '',
                    blackScore: 2,
                    whiteScore: 2
                });
            }, []);

            useEffect(() => {
                initGame();
            }, [initGame]);

            // Calculate valid moves whenever board or player changes
            useEffect(() => {
                if (board.length === 0) return;
                
                const moves = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (isValidMove(board, r, c, currentPlayer)) {
                            moves.push(`${r},${c}`);
                        }
                    }
                }
                setValidMoves(moves);

                // Check for no moves or game over
                if (moves.length === 0 && !gameStatus.isOver) {
                    const opponent = currentPlayer === BLACK ? WHITE : BLACK;
                    const opponentMoves = hasValidMoves(board, opponent);
                    
                    if (!opponentMoves) {
                        endGame(board);
                    } else {
                        // Pass turn
                        setGameStatus(prev => ({ ...prev, message: `${currentPlayer === BLACK ? 'Black' : 'White'} has no moves. Passing...` }));
                        setTimeout(() => {
                            setGameStatus(prev => ({ ...prev, message: '' }));
                            setCurrentPlayer(opponent);
                        }, 2000);
                    }
                }
            }, [board, currentPlayer, gameStatus.isOver]);

            const isValidMove = (currentBoard, r, c, player) => {
                if (currentBoard[r][c] !== EMPTY) return false;
                const opponent = player === BLACK ? WHITE : BLACK;

                for (let [dr, dc] of DIRECTIONS) {
                    let nr = r + dr;
                    let nc = c + dc;
                    let foundOpponent = false;

                    while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === opponent) {
                        nr += dr;
                        nc += dc;
                        foundOpponent = true;
                    }

                    if (foundOpponent && nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === player) {
                        return true;
                    }
                }
                return false;
            };

            const hasValidMoves = (currentBoard, player) => {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (isValidMove(currentBoard, r, c, player)) return true;
                    }
                }
                return false;
            };

            const handleCellClick = (r, c) => {
                if (gameStatus.isOver) return;
                if (!validMoves.includes(`${r},${c}`)) return;

                const newBoard = board.map(row => [...row]);
                newBoard[r][c] = currentPlayer;
                
                flipDiscs(newBoard, r, c, currentPlayer);
                
                setBoard(newBoard);
                updateScore(newBoard);
                setCurrentPlayer(currentPlayer === BLACK ? WHITE : BLACK);
            };

            const flipDiscs = (currentBoard, r, c, player) => {
                const opponent = player === BLACK ? WHITE : BLACK;

                for (let [dr, dc] of DIRECTIONS) {
                    let nr = r + dr;
                    let nc = c + dc;
                    let discsToFlip = [];

                    while (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === opponent) {
                        discsToFlip.push({r: nr, c: nc});
                        nr += dr;
                        nc += dc;
                    }

                    if (discsToFlip.length > 0 && nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === player) {
                        for (let disc of discsToFlip) {
                            currentBoard[disc.r][disc.c] = player;
                        }
                    }
                }
            };

            const updateScore = (currentBoard) => {
                let black = 0;
                let white = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (currentBoard[r][c] === BLACK) black++;
                        else if (currentBoard[r][c] === WHITE) white++;
                    }
                }
                setGameStatus(prev => ({ ...prev, blackScore: black, whiteScore: white }));
            };

            const endGame = (currentBoard) => {
                let black = 0;
                let white = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (currentBoard[r][c] === BLACK) black++;
                        else if (currentBoard[r][c] === WHITE) white++;
                    }
                }
                
                let winner = '';
                if (black > white) winner = 'Black Wins!';
                else if (white > black) winner = 'White Wins!';
                else winner = 'Draw!';

                setGameStatus({
                    isOver: true,
                    message: `Game Over. ${winner}`,
                    blackScore: black,
                    whiteScore: white
                });
            };

            return (
                <div className="container">
                    <header>
                        <h1>Reversi</h1>
                        <div className="game-info">
                            <div className={`player-score ${currentPlayer === BLACK ? 'active' : ''}`} style={{opacity: currentPlayer === BLACK ? 1 : 0.5}}>
                                <div className="disc black"></div>
                                <span>{gameStatus.blackScore}</span>
                                {currentPlayer === BLACK && !gameStatus.isOver && <span className="turn-indicator">Current Turn</span>}
                            </div>
                            <div className={`player-score ${currentPlayer === WHITE ? 'active' : ''}`} style={{opacity: currentPlayer === WHITE ? 1 : 0.5}}>
                                <div className="disc white"></div>
                                <span>{gameStatus.whiteScore}</span>
                                {currentPlayer === WHITE && !gameStatus.isOver && <span className="turn-indicator">Current Turn</span>}
                            </div>
                        </div>
                        <button id="restart-btn" onClick={initGame}>New Game</button>
                        <div className="message">{gameStatus.message}</div>
                    </header>
                    
                    <div className="board-container">
                        <div className="board">
                            {board.map((row, r) => (
                                row.map((cellValue, c) => (
                                    <div 
                                        key={`${r}-${c}`}
                                        className={`cell ${validMoves.includes(`${r},${c}`) && !gameStatus.isOver ? 'valid-move' : ''}`}
                                        onClick={() => handleCellClick(r, c)}
                                    >
                                        {cellValue !== EMPTY && (
                                            <div className={`cell-disc ${cellValue === BLACK ? 'black' : 'white'} new`}></div>
                                        )}
                                    </div>
                                ))
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
